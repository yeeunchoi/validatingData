E2[14,2]
E2
location[14,2]
location[14,]
data[14,]
as.vector(E2[row])
as.vector(E2[,row])
E2[,row]
E2[,"row"]
sort(E2[,"row"])
as.vector(sort(E2[,"row"]))
as.vector(as.numeric(sort(E2[,"row"])))
l <- as.vector(as.numeric(sort(E2[,"row"])))
l
for (i in length(l)){
data[i,]
}
as.vector(as.numeric(sort(E2[,"row"])))
l<-c((as.numeric(sort(E2[,"row"]))))
l
# data 에 잘못되었는지 보여주려면 row num만 필요함
for (i in l){
print(i)
}
# data 에 잘못되었는지 보여주려면 row num만 필요함
for (i in l){
print(data[i,])
}
# data 에 잘못되었는지 보여주려면 row num만 필요함
# actual row number도 있어야함
for (i in l){
print(data[i,])
}
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
packages <- c("dplyr", "readxl", "stringr", "editrules")
ipak(packages)
# open data/ metadata files
data<-readxl::read_xlsx("testdata.xlsx")
meta<-readxl::read_xlsx("testmetadata.xlsx")
meta<-meta[-1,] # omitting the first row of the metadata b/c it contains nothing
# making lists for header and label to check if they match
heading <- c(names(data)) # header of data
labels <-unlist(c(dplyr::select(meta,Label)),use.names=FALSE) # Labels of metadata
identical(heading,labels) # includes all labels in metadata?
### NULL CHECKING
# a list of columns that should never contain null
# convert every character into lower case ? > necessary??
nullList<-meta %>%
filter(Nullble == "no") %>%
select(Label)
nullList<-rep(nullList)
# filtering columns that should not contain null values
for (item in nullList){
selected<- data %>%
dplyr::select(item)
}
# store in isnull data frame
isnull<-data.frame(is.na(selected))
isnull
length(isnull[isnull == TRUE])  # count null 갯수 to be stored in summary text file
as.data.frame(which(isnull=="TRUE", arr.ind = TRUE)) # store the result in a data frame to be stored in result text file
# row num + 1 for the actual table
write.table(export, file= "testing.txt", sep=" ") # write data table into a text file
export <- as.data.frame(which(isnull=="TRUE", arr.ind = TRUE)) # store the result in a data frame to be stored in result text file
# row num + 1 for the actual table
write.table(export, file= "testing.txt", sep=" ") # write data table into a text file
# metadata analysis
# for numerical data only
a<-as.data.frame(na.omit(select(meta, Label, X__1, X__2)))
a
for (i in 1:nrow(a)){
min <- paste(a[i,1], ">=", a[i,2])
max <- paste(a[i,1], "<=", a[i,3])
rules<- c(min, max)
}
rules
# row num + 1 for the actual table
export
# row num + 1 for the actual table
export[row]
# row num + 1 for the actual table
export[,1]
data[export[,1]]
# list of row numbers to be printed
alist<-c((as.numeric(sort(export[,"row"]))))
# data 에 잘못되었는지 보여주려면 row num만 필요함
# actual row number도 있어야함
for (i in alist){
print(data[i,])
}
# data 에 잘못되었는지 보여주려면 row num만 필요함
# actual row number도 있어야함
for (i in alist){
write.table(print(data[i,]), file = "testing.txt", sep = ' ')
}
# data 에 잘못되었는지 보여주려면 row num만 필요함
# actual row number도 있어야함
for (i in alist){
paste(data[i,])
}
# data 에 잘못되었는지 보여주려면 row num만 필요함
# actual row number도 있어야함
for (i in alist){
print(data[i,])
}
# data 에 잘못되었는지 보여주려면 row num만 필요함
# actual row number도 있어야함
for (i in alist){
print(data[i,])
}
for (i in alist){
trial = c(trial, data[i,])
#print(data[i,])
}
# data 에 잘못되었는지 보여주려면 row num만 필요함
# actual row number도 있어야함
trial = NULL
for (i in alist){
trial = c(trial, data[i,])
#print(data[i,])
}
trial
for (i in alist){
trial = c(trial, as.data.frame(data[i,]))
#print(data[i,])
}
trial
for (i in alist){
trial[nrow()+1,] = data[i,]; next
}
for (i in alist){
trial[nrow(trial)+1,] = data[i,]; next
}
for (i in alist){
trial[nrow(trial)+1,] = data[i,]
}
# data 에 잘못되었는지 보여주려면 row num만 필요함
# actual row number도 있어야함
trial = data.frame()
for (i in alist){
trial[nrow(trial)+1,] = data[i,]
}
trial
for (i in alist){
trial[nrow(trial)+1,] = data[i,]; next
}
trial
View(trial)
View(nullList)
View(meta)
# list of row numbers to be printed
alist<-c((as.numeric(sort(export[,"row"]))))
alist
for (i in alist){
location <- data.frame(data[i,])
}
location
?extract
for (i in alist){
location <- data.frame(data[i,])
write.table(location, "testing.txt")
}
for (i in alist){
s<- subset(data, data[i,])
}
for (i in alist){
s<- subset(data, data[i,] == data[i,])
}
for (i in alist){
cat(paste(data[i,]), file = "testing.txt")
}
for (i in alist){
cat(paste(data[i,]), file = "testing.txt", append = T)
}
for (i in alist){
cat(paste(data[i,]), file = "testing.txt", sep = " ", append = T)
}
for (i in alist){
cat(paste(data[i,]), '\n',file = "testing.txt", sep = " ", append = T)
}
# include column and row number and should be formatted
for (i in alist){
cat(paste(data[i,]), '\n',file = "testing.txt", sep = "\t", append = T)
}
isnull
for (i in 1:nrow(a)){
min <- paste(a[i,1], ">=", a[i,2])
max <- paste(a[i,1], "<=", a[i,3])
rules<- c(min, max)
}
rules
for (i in 1:nrow(a)){
min <- paste(a[i,1], ">=", a[i,2])
cat(min, '\n', file = "rules.txt", append = T)
max <- paste(a[i,1], "<=", a[i,3])
cat(min, '\n', file = "rules.txt", append = T)
}
for (i in 1:nrow(a)){
min <- paste(a[i,1], ">=", a[i,2])
cat(min, '\n', file = "rules.txt", append = T)
max <- paste(a[i,1], "<=", a[i,3])
cat(max, '\n', file = "rules.txt", append = T)
}
rule <- editrules::editfile("rules.txt")
# store rules in summary text file???  THEY must be store in some way
rule
errors <- data.frame(editrules::violatedEdits(rule, data))
errors
location<- data.frame((editrules::localizeErrors(rule, data))$adapt)
location
E1 <- as.data.frame(which(errors=="TRUE", arr.ind = TRUE)) # tells which rule has been violated
E1
E2 <- as.data.frame(which(location=="TRUE", arr.ind = TRUE))
?drop
#########################################################
# list of row numbers to be printed
l<-c((as.numeric(sort(E2[,"row"]))))
E2 <- as.data.frame(which(location=="TRUE", arr.ind = TRUE))
location<- data.frame((editrules::localizeErrors(rule, data))$adapt)
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
packages <- c("dplyr", "readxl", "stringr", "editrules")
ipak(packages)
# open data/ metadata files
data<-readxl::read_xlsx("testdata.xlsx")
meta<-readxl::read_xlsx("testmetadata.xlsx")
meta<-meta[-1,] # omitting the first row of the metadata b/c it contains nothing
# making lists for header and label to check if they match
heading <- c(names(data)) # header of data
labels <-unlist(c(dplyr::select(meta,Label)),use.names=FALSE) # Labels of metadata
identical(heading,labels) # includes all labels in metadata?
### NULL CHECKING
# a list of columns that should never contain null
# convert every character into lower case ? > necessary??
nullList<-meta %>%
filter(Nullble == "no") %>%
select(Label)
nullList<-rep(nullList)
# filtering columns that should not contain null values
for (item in nullList){
selected<- data %>%
dplyr::select(item)
}
# store in isnull data frame
isnull<-data.frame(is.na(selected))
isnull
length(isnull[isnull == TRUE])  # count null 갯수 to be stored in summary text file
export <- as.data.frame(which(isnull=="TRUE", arr.ind = TRUE)) # store the result in a data frame to be stored in result text file
# list of row numbers to be printed
alist<-c((as.numeric(sort(export[,"row"]))))
alist
# include column and row number and should be formatted
for (i in alist){
cat(paste(data[i,]), '\n',file = "testing.txt", sep = "\t", append = T)
}
# metadata analysis
# for numerical data only
a<-as.data.frame(na.omit(select(meta, Label, X__1, X__2)))
for (i in 1:nrow(a)){
min <- paste(a[i,1], ">=", a[i,2])
cat(min, '\n', file = "rules.txt", append = T)
max <- paste(a[i,1], "<=", a[i,3])
cat(max, '\n', file = "rules.txt", append = T)
}
rule <- editrules::editfile("rules.txt")
errors <- data.frame(editrules::violatedEdits(rule, data))
errors
E1 <- as.data.frame(which(errors=="TRUE", arr.ind = TRUE)) # tells which rule has been violated
E1
location<- data.frame((editrules::localizeErrors(rule, data))$adapt)
location
E2 <- as.data.frame(which(location=="TRUE", arr.ind = TRUE))
#########################################################
# list of row numbers to be printed
l<-c((as.numeric(sort(E2[,"row"]))))
# data 에 잘못되었는지 보여주려면 row num만 필요함
# actual row number도 있어야함
for (i in l){
print(data[i,])
}
l
sort(alist)
alist
# list of row numbers to be printed
alist<-c((as.numeric(sort(export[,"row"]))))
alist
unique(alist)
E1
errors
location
errors <- data.frame(editrules::violatedEdits(rule, data))
errors
E1 <- as.data.frame(which(errors=="TRUE", arr.ind = TRUE)) # tells which rule has been violated
E1
isnull
length(isnull[isnull == TRUE])  # count null 갯수 to be stored in summary text file
export <- as.data.frame(which(isnull=="TRUE", arr.ind = TRUE)) # store the result in a data frame to be stored in result text file
# row num + 1 for the actual table
export
export
isnull
export
# assign row number
data %>%
mutate(rownum = 1:n())
data
# assign row number
data <- data %>%
mutate(rownum = 1:n())
data
# open data/ metadata files
orgdata<-readxl::read_xlsx("testdata.xlsx")
# assign row number
data <- orgdata %>%
mutate(rownum = 1:n())
orgdata
data
# making lists for header and label to check if they match
heading <- c(names(orgdata)) # header of data
labels <-unlist(c(dplyr::select(meta,Label)),use.names=FALSE) # Labels of metadata
identical(heading,labels) # includes all labels in metadata?
# making lists for header and label to check if they match
heading <- c(names(data)) # header of data
labels <-unlist(c(dplyr::select(meta,Label)),use.names=FALSE) # Labels of metadata
identical(heading,labels) # includes all labels in metadata?
nullList<-rep(nullList)
# filtering columns that should not contain null values
for (item in nullList){
selected<- data %>%
dplyr::select(item)
}
# store in isnull data frame
isnull<-data.frame(is.na(selected))
isnull
print("\t")
print("\t")
print("\tNULL")
print("\tNULL")
paste("\t", "PRINT")
summary(orgdata)
dim(orgdata)
nrow(orgdata)
ncol(orgdata)
meta
nrow(meta)
length(isnull[isnull == TRUE])  # count null 갯수 to be stored in summary text file
E1 <- as.data.frame(which(errors=="TRUE", arr.ind = TRUE)) # tells which rule has been violated
E1
nrow(E1)
heading
# making lists for header and label to check if they match
heading <- c(names(orgdata)) # header of data
heading
# generating two text files : summary and result (output)
writeLines(paste("Results","\n" ),"results.txt") #writing lines into the file
cat(paste("Number of Rows in the data :", '\t', datarow, '\n',file = "results.txt", sep = "\t", append = T))
# to be included in summary file
datarow<-nrow(orgdata) # num of rows in data
cat(paste("Number of Rows in the data :", '\t', datarow, '\n',file = "results.txt", sep = "\t", append = T))
writeLines(paste("Number of Rows in the data :", '\t', datarow, '\n',file = "results.txt", sep = "\t", append = T))
writeLines(paste("Number of Rows in the data :", '\t', datarow, '\n',file = "results.txt", append = T))
writeLines(paste("Number of Rows in the data :", '\t', datarow, '\n', append = T), "results.txt")
writeLines(paste("Number of Rows in the data :", '\t', datarow, '\n'), "results.txt")
datacol<-ncol(orgdata) # num of cols in data
writeLines(paste("Number of Columns in the data : ", datacol, '\n'), "results.txt")
# generating two text files : summary and result (output)
writeLines(paste("Results","\n" ),"results.txt") #writing lines into the file
writeLines(paste("Number of Rows in the data : ", datarow, '\n', append = T), "results.txt")
writeLines(paste("Number of Columns in the data : ", datacol, '\n', append = T), "results.txt")
writeLines(paste("Number of Columns in the data : ", datacol, '\n',
"Number of Rows in the data : ", datarow, '\n'), "results.txt")
writeLines(paste("Number of Columns in the data : ", datacol, '\n',
"Number of Rows in the data : ", datarow, '\n'), "results.txt")
?Carseats
??Carseats
alist
blist <- c((as.numeric(sort(E1[,"row"]))))
blist
for (i in blist){
cat(paste(data[i,],'\n', file = "testing2.txt", sep = "\t", append=T))
}
for (i in alist){ # index number
cat(paste(data[i,]), '\n',file = "testing.txt", sep = "\t", append = T)
}
for (i in blist){
cat(paste(data[i,]),'\n', file = "testing2.txt", sep = "\t", append=T)
}
??ReporteRs
??kable
install.packages("kable")
kable(data)
install.packages("knitr")
knitr::kable(data)
knitr::kable(data, format = "rst")
class(data)
# formatting test
new<- knitr::kable(data, format = "rst")
write.table(new, file = "format.txt")
class(new)
errors
knitr::kable(errors)
knitr::kable(errors, format ="rst")
class(new)
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
packages <- c("dplyr", "readxl", "editrules", "knitr")
ipak(packages)
knitr::opts_chunk$set(echo = TRUE)
# A function to check if necessary packages are downloaded
# if downloaded, load them to the program
# if not, download the package and load
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
# Required Packages
packages <- c("dplyr", "readxl", "editrules", "knitr")
ipak(packages)
# Original Data
orgdata <- readxl::read_xlsx("testdata.xlsx")
# generating a new data with assigned row numbers for future reference
data<- orgdata %>%
mutate(rownum = 1:n())
# Metadata
metadata <- readxl::read_excel("testmetadata.xlsx")
# Omitting the first row b/c it contains nothing
metadata<- metadata[-1,]
# printing data/metadata
head(orgdata)
head(metadata)
# make a list of columns in the data
heading <- c(names(orgdata))
# make a list of items in the metadata
labels <- unlist(c(dplyr::select(metadata, Label)), use.names = FALSE)
# check to see if two are identical
identical(heading, labels)
# if this returns false, the program should be terminated
# make a list of columns that should never contain null based on the information given in metadata
nullList <- metadata %>%
filter(Nullble == "no") %>%   # filter where the nullable section says no,
select(Label)                 # and select labels to store them in a vector
nullList<- rep(nullList)
# filtering columns that should not contain null values
for (item in nullList){
selected<- data %>%
dplyr::select(item)
}
isnull <- data.frame(is.na(selected))
nullresult <- as.data.frame(which(isnull == "TRUE", arr.ind = TRUE))
# gives output of row & col numbers which contain NA
rowlist1 <- c((as.numeric(sort(nullresult[,"row"]))))
rowlist1 <- unique(rowlist1)  # remove duplicates
length(rowlist1)
df1 = data.frame(ncol = ncol(data), nrow = length(rowlist1))
for (i in 1:length(rowlist1)){
df1[i,]<- data[(rowlist1[i]),]
}
data[1,]
rowlist1[1]
df1 = data.frame()
for (i in 1:length(rowlist1)){
df1[i,]<- data[(rowlist1[i]),]
}
df1
rowlist1
class(rowlist1[1])
data[1]
data[1,]
df1[1,]<- data[(rowlist1[1]),]
df1
df1[1,]<- data[(rowlist1[1]),]
df1
df1[1,]<- data[1,]
df1
for (i in 1:length(rowlist1)){
df1[i,]= data[(rowlist1[i]),]
}
df1
as.vector(data[1,])
for (i in 1:length(rowlist1)){
df1[i,]<- as.vector(data[(rowlist1[i]),])
}
df1
variables = ncol(data)
iterations = length(rowlist1)
df1 <- matrix(ncol = variables, nrow = iterations)
}
for (i in 1:iterations){
df1[i,]<-data[(rowlist1[i]),]
}
for (i in 1:iterations){
df1[i,]<-data[rowlist1[i],]
}
for (i in 1:iterations){
df1[i,]<-runif(5)
}
df1
